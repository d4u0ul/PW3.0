"O primeiro passo do aprendizado é a confusão"

Roteiro do aquecimento PSW 3.0
* Variaveis
Primeiro cria-se um ambiente virtual python na sua máquina
-pra quê precisa disso?
Ambientes virtuais são copias das instalações dos interpretadores que estão na máquina, por exemplo o python 3.7, pode ser que essa instalação seja  modificada e muitas vezes não queremos que projetos estejam vinculados à instalação principal do compilador/interpretador que temos na máquina que pode ser, por exemplo, atualizada.
Então para cada projeto que estejamos criando, devemos criar um novo ambiente virtual.


python3 -m venv venv

python3: chame o python
-m: passe parâmetros
venv: crie um virtualEnv
venv: nome que eu dou para o meu interpretador python(padrão é venv)

após isso, algumas pastas e subpastas são criadas com várias configurações pré-definidas de um ambiente virtual
Depois disso precisamos informar que sempre que quisermos rodar um código, este deverá ser feito por meio desta cópia(venv) do interpretador por meio do comando abaixo

source venv/bin/activate (linux)
venv\scripts\activate(windows)

daí aparece a palavra(venv) para dizer que o venv foi ativado e está rodando
-Tipos de dados 
-Entrada de dados

nome = input("Digite o seu nome: ")
print(f"O seu nome é {nome}")
 
Para outras linguagens de programação que não o python constantes são escritas com letras maiúsculas e não podem ser alteradas após serem definidas, no python mesmo sendo escritas com as letras maiúsculas elas podem ser alteradas a PEP8(guias de estilo) que indica a utilização de letras maiúsculas para constantes para que fique mais fácil apra outros desenvolvedoores consigam ler o código com mais clareza 

Arredondamento de variáveis
from math import ceil(arredonda para cima), floor(arredonda para baixo) 

-Conversão de dados

print(3+2) ==> 5
print(3-2) ==> 1
print(3/2) ==> 1.5
print(3//2) ==> 1 (divisão por inteiro)
print(3%2) ==> 1 
print(3*2) ==> 6
print(3**2) ==> 9
print(9**(1/2)) ==> 3

-laço de repetição
break finaliza  a repetição


1) Iniciando o projeto

primeiro vamos instalar o django(framework) e o pillow(biblioteca que o django usa para manipular imagens)

agora precisamos startar o nosso projeto django. A partir do momento que temos o django instalado, basta rodarmos:


django-admin startproject freelaway .

Onde são respectivamente comandoDjango inicializaProj nomeDoProjeto pontoQuaMostraOndeComeçaOProj

Após fazer isso o Django cria todo o projeto para nós dentro da pasta nomeDoProjeto, mostrando toda uma estrutura básica independente do qual pequeno ou grande esse projeto seja, por ex:

2)Arquivos do projeto Django
O settings.py é o arquivo de configuração e é com ele que conseguimos definir algummas configurações básicas do nosso projeto por exemplo:
DEBUG: que quando estiver 'True' nós estamos em modo de desenvolvimento e quando ela estiver em false, nós já a colocamos em produção 
ALLOWED_HOSTS: são as máquinas que podem acessa o meu aplicativo 
SECRET_KEY: utilizada para fazer hash e criptografia 
DATABASES: Digamos qeu estamos utilizando o MYSQL e de repente precisamos mudar para o POSTGREE ou SQLITE não precisamos mexer em nada do projeto, precisaremos apenas mudar essa variável
LANGUAGE_CODE: "pt-BR"
TIME_ZONE: "America/Sao_Paulo"


O urls.py é onde definimos as rotas da nossa aplicação exemplo


url/login
url/home
url/cadastro

Quando acessamos uma determinada rota ele exibe algo de diferente para cada página requerida

O wsgi.py é o web server gate interface usado no deploy da aplicação
O asgi.py é parecido mas é usado apra uma aplicação assíncrona

e por último temos o manage.py qye é o nosso cli(command line interface) é como se fosse um programa, mas em vez de uma interface gráfica quando pedimos uma ação para o programa , ele executará uma ação dada pela linha de comando.
Ao executarmos o arquivo manager.py podemos por exemplo inicializar o servidor com o comando runserver:

    $python3 manager.py runserver

ao acessarmos o caminho definido como URI(http://127.0.0.1:8000/) do servidor que está rodando temos acesso a tela do Django quando não tem nada instalado

3) Configurando os arquivos estáticos


Devemos copiar as configurações pré-determinada no projeto 
STATIC_URL = '/static/' #url para acessá-los
STATICFILES_DIRS = (os.path.join(BASE_DIR, 'templates/static'),) #quais pastas eles vão ficar
STATIC_ROOT = os.path.join('static')
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
MEDIA_URL = '/media/'

Os arquivos estáticos são por exemplo a Logo do sistema, os css, javascripts ou seja os arquivos que não são dinâmicos, que vão estar na aplicação estarão nos arquivos estáticos


4 passo - criação de um App (dividir para conquistar)

 Vamos dividir o nosso problema gigante em pequenos problemas, então para cada um dos nossos problemas devemos criar um App, por ex:
 -login
 -cadastro
 -recuperação de senha
 -listagem dos jobs
 -perfil do usuário

Para inicializar um App é muito simples, basta digitar o comando

    $python3 manage.py startapp autenticacao (no windows é python)

indicando o nome do app no final
Quando rodamos o comando acima, o django cria uma nova pasta(autenticacao) no projeto com os arquivos que serão necessários para rodar aquele app. 
Ao criar um app, devemos informar ao Django da criação deste app nos arquivos 

    * freewlaway/settings.py adicionando na tag Application definition os INSTALLED_APPS

        INSTALLED_APPS = [
            'django.contrib.admin',                                     #app que já vem como padrão no Django    
            'django.contrib.auth',                                      #app que já vem como padrão no Django    
            'django.contrib.contenttypes',                              #app que já vem como padrão no Django            
            'django.contrib.sessions',                                  #app que já vem como padrão no Django        
            'django.contrib.messages',                                  #app que já vem como padrão no Django        
            'django.contrib.staticfiles',                               #app que já vem como padrão no Django            
            'autenticacao',                                             #app que criamos e adicionamos manualmente
        ]

    *frewlaway/urls.py - adicionando em urlpatterns criando um caminho para quando o meu usuário acessá-lo ele caia na minha aplicação 

        urlpatterns = [
            path('admin/', admin.site.urls),                #url padrão do django
            path('auth/', include('autenticacao.urls'))     #url que adicionamos, mas q ainda não existe na pasta de autenticação, devemos criá-lo
        ]

    *autenticacao/urls.py - perceba que o arquivo urls.py não existe dentro da pasta autenticacao, logo devemos criá-lo e em criar uma estrutura igual ao urls.py do   freewlaway.

            from django.urls import path

            urlpatterns = [
            ]

        * note que o problema autenticação ainda é muito grande com cadastro, login, senha, recuperação
        * quando o usuário acessar meudominio/auth ele acessa o app auth, mas para acessar as subrotas com os subproblemas de auth ele deve acessar outros paths que são derivações do /path e que devem ser colocadas dentro de urls.py de autenticacao/
        * o django segue um padrão de arquitetura de software chamado mvt(model-view-template)
            -model: arquivo model onde vai ficar uma camada da aplicação, ou seja um arquivo onde vai ficar separado tudo que for relacionado a conexão,pesquisa, inserção de banco de dados
            -view: arquivo view, onde vai ficar a lógica da nossa aplicação, onde fica toda aquela parte onde recebemos uma request e retornamos uma response, logo pegar o nome do usuário e verificar se ele existe, ou um e-mail/senha válido/inválido todo esse processamento fica aqui.
            -template: arquivo template, que é de fato a interface que o usuário vai receber as informações que no nosso caso, seria o html, onde se tem imagens, botões, campos para o usuário interagir.
        * Quando um usuário acessa uma rota, eu quero que ele seja redirecionado para uma view que é uma função do python que vai receber uma requisição pedida do usuário e vai devolver um response com o conteúdo do que o usuário pediu como resposta, logo devemos fazer o import do arquivo views para dentro o autenticacao/urls.py

            from django.urls import path
            from . import views #import do arquivo views

            urlpatterns = [
                path('cadastro/', views.cadastro, name = 'cadastro') # onde temos:  caminhoDoPath, funçãoDentroDeViews, nomeDaRota
            ]
        
    *autenticacao/views.py - não devemos esquecer de criar a função cadastro dentro da views.py que é a função que deve retornar o response da request no path auth/cadastro

        from django.http import HttpResponse #é preciso iportar o response da função cadastro

        def cadastro(request):
            return HttpResponse('cadastro')

Vamos ver se está funcionando:
Após isso, rodamos o servidor de novo e podemos testar no navegador outra vez
Ao acessarmos a página vazio(http://127.0.0.1:8000/) não funciona nada, pois não configuramos para que o django pudesse exibir algo nessa url.
Se acessarmos a página auth/(http://127.0.0.1:8000/auth/) também não funciona pois não criamos nenhuma view para este caminho, na realidade este caminho só direciona para autenticacao/urls.py 
Mas perceba que dentro do (http://127.0.0.1:8000/auth/) temos uma outra rota(http://127.0.0.1:8000/auth/cadastro/) que ela sim tem uma view(httpresponse) definida que pode ser exibida 

4 passo - criação sozinho de uma rota login

    add uma nova urlpattern em autenticacao/urls.py para a rota login/

        urlpatterns=[
            ...
            path('login/', login.views, name='login'),
        ]
    add uma nova função em views chamada login que retorna o response da chamada no link /auth/login/

        def login(request):
            return HttpResponse('login')

Perceba que até agora nós apenas retornamos strings nas requests, mas num projeto real o que queremos retornar são páginas e elementos web.
para isso, precisamos renderizar o html com uma função que já vem importada 

    from django.shortcus import render  # dentro de autenticacao/views

Trocando agora a HttpResponse de views.cadastro() pela função render temos:

    def cadastro(request):
        return render(request, 'cadastro.html')

    Na função render precisamos saber qual foi a requisição do usuário, o caminho do template html('cadastro.html'). 
    Por padrão o django procura esse arquivo html dentro de uma pasta chamada templates(autenticacao/templates/cadastro.html), logo devemos criar a pasta 'templates' e o arquivo 'cadastro.html'

5º passo - Vc já viu que muitos sites têm partes da página que se repetem durante as navegações como barra de navegação e rodapé da página. Isso quer dizer que temos de para todas as páginas dentro do projeto, teremos que criar repetidamente essa parte da página em html? não, para isso criamos um arquivo chamado base.html onde colocamos todas as partes do html que sejam comuns em vários arquivos e no arquivo cadastro.html ou login.html a gnt só estende o base e o padrão fica no base.html e assim não precisamos repetir o mesmo código. 

Para criar um base.html, precisamos criar uma pasta de templates no core do nosso projeto(freewlaway) 
No arquivo freelaway/settings nós encontramos uma constante chamada TEMPLATES. Essa constante é uma lista de dicionários e em cada dicionário nós temos uma lista chamada DIRS on devemos colocar DIRS =[os.path.join()]. O os.path.join()  basicamente faz uma concatenação das 2 partes que ele está juntando, no caso os 2 caminhos(path), pórem se colocássemos apenas uma concatenação comum (+) teríamos algumas incompatibilidades dependendo do sistema em que o código rodar, por exemplo o linux tem como separador de pastas "/" e o windows "\" o os.path.join() faz essa configuração do jeito certo de se escrever o caminho para nós.
Assim, devemos concatenar BASE_DIR{que é uma variável do próprio settings que referencia o lugar no OS onde o código está sendo rodado} com a pasta templates na raiz principal do projeto PS3.0/templates

    DIRS = [os.path.join(BASE_DIR,"templates")]

depois disso, criamos a pasta e o arquivo PS3.0/templates/base.html
para não nos preocuparmos muito com o front end desta parte do projeto, podemos ir diretamente no site do bootstrap getbootstrap.com e pegar um já feito em docs o starter template.
==============================================================================================================
<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    {% block 'head' %} 
    {% endblock %}
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css">
    <title>{% block 'title' %}{% endblock %}</title>
</head>

<body class="fundo">
    {% block 'body' %}{% endblock %}
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js">

    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>
==============================================================================================================

O código está disponível com algumas pequenas diferenças no pdf. As principais estão nos blocos do django que forma adicionados ao código do bootstrap, sendo eles 

{% block 'head' %}

{% endblock %}

Um block do django é uma tag que tudo que eu quiser colocar nessa tag chamada 'head' ou seja estendê-la de outro lugar ou colocá-la em algum outro lugar, essas tags serão substituídas pelo que eu quero colocar no lugar, por exemplo a tag titile que vai substituir o título

    {% block 'title' %}{% endblock %}

e todo o resto, ele mantém.
Voltando para o cadastro.html, devemos apagar tudo e mandar ele estender de base.html para não ficar repetindo o código base da aplicação.

    {% extends 'base.html' %}
    
    e também devemos dizer o que e onde queremos colocar, nesse caso estamos colocando a plavra TESTE no body.
    {% block 'body' %}
        <h1>
        TESTE
        </h1>
    {% endblock %}

    além disso tbm podemos definir o título da página com o block title

    {%block 'title'%}
        Cadastro | freewlaway
    {%endblock%}



6ºpasso - desenvolva o cadastro.html 
Há um exemplo feito no pdf com todos os blocks que precisamos adicionar no cadastro.html

=======================================================================================================

{% extends 'base.html' %}
{% load static %}

{% block 'head' %}
<link rel="stylesheet" href="{% static 'autenticacao/css/cadastro.css' %}">
{% endblock %}

{% block 'body' %}
<div class="box">
<form>
<h1 class="titulo font-degrade borda-bottom-degrade">INSCREVA-SE</h2>
<br>
<span class="span-descricao">Nome de usuário:</span>
<input type="text" class="form-control input-cadastro" name="username">
<br>
<span class="span-descricao">Senha:</span>
<input type="password" class="form-control input-cadastro" name="password">
<br>
<span class="span-descricao">Confirmar senha:</span>
<input type="password" class="form-control input-cadastro" name="confirm-password">
<br>
<input type="submit" value="CADASTRAR" class="btn btn-success btn-lg">
<a href="#" class="btn btn-primary btn-lg">LOGIN</a>
</form>
</div>
{% endblock %}

=======================================================================================================

